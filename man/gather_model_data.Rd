% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess_export.R
\name{gather_model_data}
\alias{gather_model_data}
\title{Gather model data from a formula}
\usage{
gather_model_data(
  formula,
  model = c("DyNAM", "REM"),
  sub_model = c("choice", "choice_coordination", "rate"),
  data = NULL,
  control_preprocessing = set_preprocessing_opt(),
  progress = getOption("progress")
)
}
\arguments{
\item{formula}{a formula object that defines at the
left-hand side the dependent
network (see \code{\link[=make_dependent_events]{make_dependent_events()}}) and at the right-hand side the
effects and the variables for which the effects are expected to occur
(see \code{vignette("goldfishEffects")}).}

\item{model}{a character string defining the model type.
Current options include \code{"DyNAM"}, \code{"DyNAMi"} or \code{"REM"}
\describe{
\item{DyNAM}{Dynamic Network Actor Models
(Stadtfeld, Hollway and Block, 2017 and Stadtfeld and Block, 2017)}
\item{DyNAMi}{Dynamic Network Actor Models for interactions
(Hoffman et al., 2020)}
\item{REM}{Relational Event Model (Butts, 2008)}
}}

\item{sub_model}{A character string specifying the sub-model to be estimated.
It can be \code{"rate"} to model the waiting times between events,
\code{"choice"} to model the choice of the receiver, or \code{"choice_coordination"}
to model coordination ties. See details.
\describe{
\item{choice}{a multinomial receiver choice model \code{estimate_dynam()}
(Stadtfeld and Block, 2017).
A multinomial group choice model \code{estimate_dynami()} (Hoffman et al., 2020)}
\item{choice_coordination}{a multinomial-multinomial model for coordination
ties \code{estimate_dynam()} (Stadtfeld, Hollway and Block, 2017)}
\item{rate}{A individual activity rates model \code{estimate_dynam()}
(Stadtfeld and Block, 2017).
Two rate models, one for individuals joining groups and one for individuals
leaving groups, jointly estimated \code{estimate_dynami()}(Hoffman et al., 2020)}
}}

\item{data}{a \code{data.goldfish} object created with \code{\link[=make_data]{make_data()}}.
It is an environment that contains the nodesets, networks,
attributes and dependent events objects. Default to \code{NULL}.}

\item{control_preprocessing}{An object of class
\code{"preprocessing_options.goldfish"}, usually the result of a call to
\code{\link[=set_preprocessing_opt]{set_preprocessing_opt()}}. This object contains parameters that control
the data preprocessing. See \code{\link[=set_preprocessing_opt]{set_preprocessing_opt()}} for details on
the available parameters.}

\item{progress}{logical indicating whether should print a minimal output
to the console of the progress of the preprocessing and
estimation processes.}
}
\value{
a list object including:
\describe{
\item{stat_all_events}{a matrix. The number of rows can be up to the number
of events times the number of actors
(square number of actors for the REM).
Rigth-censored events are included when the model has an intercept.
The number of columns is the number of effects in the model.
Every row is the effect statistics at the time of the event for each actor
in the choice set or the sender set.}
\item{n_candidates}{
a numeric vector with the number of rows related with an event.
The length correspond to the number of events
plus right censored events if any.}
\item{selected}{a numeric vector with the position of the
selected actor (choice model), sender actor (rate model), or
active dyad (choice-coordination model, REM model).
Indexing start at 1 for each event.}
\item{sender, receiver}{
a character vector with the label of the sender/receiver actor.
For right-censored events the receiver values is not meaningful.}
\item{has_intercept}{
a logical value indicating if the model has an intercept.}
\item{namesEffects}{a character vector with a short name of the effect.
It includes the name of the object used to calculate the effects and
modifiers of the effect, e.g., the type of effect, weighted effect.}
\item{effectDescription}{
a character matrix with the description of the effects.
It includes the name of the object used to calculate the effects and
additional information of the effect, e.g., the type of effect,
weighted effect, transformation function, window length.}
}
If the model has an intercept and the sub_model is \code{rate} or model is \code{REM},
additional elements are included:
\describe{
\item{timespan}{
a numeric vector with the time span between events,
including right-censored events.}
\item{isDependent}{
a logical vector indicating if the event is dependent or right-censored.}
}
}
\description{
Gather the preprocess data from a formula given a model and sub model,
where the output corresponds to the data structure used by the engine
\code{gather_compute}; see \link{estimate}.
}
\details{
It differs from the \code{estimate_dynam()}, \code{estimate_rem()} and
\code{estimate_dynami()} output when the argument \code{preprocessing_only}
is set to \code{TRUE} regarding the memory space requirement.
The \code{gather_model_data()} produces a list where the first element
is a matrix that could have up to the number of events times
the number of actors rows and the number of effects columns.
For medium to large datasets with thousands of events and
thousands of actors, the memory RAM requirements are large and,
therefore, errors are produced due to a lack of space.
The advantage of the data structure is that it can be adapted
to estimate the models (or extensions of them) using standard packages
for generalized linear models (or any other model)
that use tabular data as input.
}
\examples{
data("Fisheries_Treaties_6070")
states <- make_nodes(states)
states <- link_events(states, sovchanges, attribute = "present")
states <- link_events(states, regchanges, attribute = "regime")
states <- link_events(states, gdpchanges, attribute = "gdp")

bilatnet <- make_network(bilatnet, nodes = states, directed = FALSE)
bilatnet <- link_events(bilatnet, bilatchanges, nodes = states)

createBilat <- make_dependent_events(
  events = bilatchanges[bilatchanges$increment == 1, ],
  nodes = states, default_network = bilatnet
)

fisheriesData <- make_data(createBilat)

gatheredData <- gather_model_data(
  createBilat ~ inertia(bilatnet) + trans(bilatnet) + tie(contignet),
  model = "DyNAM", sub_model = "choice_coordination",
  data = fisheriesData
)

}
